{"service_name":"php-coveralls","service_event_type":"manual","repo_token":"bPW6ZpZ0MhjvPjhkE4N4PM3nw54k5wwMz","git":{"branch":"master","head":{"id":"77379d13e2ffde13b794c54bfd597b8dc7150300","author_name":"KEINOS","author_email":"github@keinos.com","committer_name":"KEINOS","committer_email":"github@keinos.com","message":"Update composer.json"},"remotes":[{"name":"origin","url":"https:\/\/github.com\/KEINOS\/KVSQLite3.git"},{"name":"origin","url":"git@github.com:KEINOS\/KVSQLite3.git"}]},"run_at":"2020-06-20 08:00:47 +0000","source_files":[{"name":"src\/classes\/KVSQLite3.php","source":"<?php\n\n\/**\n *  Key Value Store with SQLite3.\n * ============================================================================\n *\n * - Driver implementation of: \/src\/psr-16\/CacheInterface.php\n * - MUST be compatible to PHP ^7.2\n * - Private\/protected methods should be implemented in: .\/KVSQLite3Methods.php\n * - Place the methods in alphabetical order.\n *\/\n\ndeclare(strict_types=1);\n\nnamespace KEINOS\\KVSQLite3;\n\nfinal class KVSQLite3 implements KVSQLite3Interface\n{\n    use KVSQLite3Properties;\n    use KVSQLite3Methods;\n\n    private const NAME_TABLE_DEFAULTX = 'table_default';\n\n    public function __construct(string $path_file_db = null)\n    {\n        try {\n            if ($path_file_db === null) {\n                $path_file_db = ':memory:';\n                $this->flag_inmemory = true;\n            }\n            $this->openDB($path_file_db);\n            $this->createTable($this->name_table_default);\n        } catch (\\Exception $e) {\n            $msg = $this->formatMessageExceptionError($e, 'Failed to open database.');\n            throw new \\RuntimeException($msg);\n        }\n    }\n\n    public function clear(): bool\n    {\n        if ($this->isDBInMemory()) {\n            return true;\n        }\n        return isset($this->path_file_db);\n    }\n\n    public function delete(string $key): bool\n    {\n        return $this->deleteValueFromDB($key);\n    }\n\n    public function deleteMultiple(iterable $keys): bool\n    {\n        $result = [];\n        foreach ($keys as $key => $value) {\n            $result[$key] = $value;\n        }\n        return empty($result);\n    }\n\n    public function get(string $key, $default = null)\n    {\n        try {\n            try {\n                $data_encoded = $this->getValueFromDB($key);\n                return $this->decodeData($data_encoded);\n            } catch (\\InvalidArgumentException $e) {\n                $msg_error = $this->formatMessageExceptionError($e);\n                throw new \\InvalidArgumentException($msg_error);\n            }\n        } catch (\\RuntimeException $e) {\n            if (is_null($default)) {\n                $msg_error = $this->formatMessageExceptionError($e);\n                throw new \\RuntimeException($msg_error);\n            }\n            return $default;\n        }\n    }\n\n    public function getMultiple(iterable $keys, $default = null): iterable\n    {\n        $result = [];\n        foreach ($keys as $key => $value) {\n            $result[$key] = $value;\n        }\n\n        return $result;\n    }\n\n    public function has(string $key): bool\n    {\n        return empty($key);\n    }\n\n    public function set(string $key, $value, $ttl = null): bool\n    {\n        return $this->setValueToDB($key, $value, $ttl);\n    }\n\n    public function setMultiple(iterable $values, $ttl = null): bool\n    {\n        $result = [];\n        foreach ($values as $key => $value) {\n            $result[$key] = $value;\n        }\n\n        return empty($result);\n    }\n\n    public function parrotry(string $name): string\n    {\n        return parrotry($name);\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,65,38,38,null,65,65,1,1,1,null,64,null,null,null,0,0,null,0,null,null,null,null,6,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,33,21,15,0,0,null,15,15,12,12,null,9,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,0,null,null,null,null,30,null,null,null,null,0,0,0,null,null,0,null,null,null,null,12,null,null]},{"name":"src\/classes\/KVSQLite3Interface.php","source":"<?php\n\n\/**\n * KVSQLite3 Interface.\n * ============================================================================\n *\n * Defines the \"public\" methods that should be implemented in KVSQLite3 class\n * other than in \"PSR-16 Simple Cache Interface\".\n *   - See: \/src\/psr-16\/CacheInterface.php\n *\n * - Private\/protected methods should be defined in: KVSQLite3Methods.php\n * - Method names should be in lowerCamelCase.\n * - Place the methods in alphabetical order.\n *\/\n\ndeclare(strict_types=1);\n\nnamespace KEINOS\\KVSQLite3;\n\ninterface KVSQLite3Interface extends \\Psr\\SimpleCache\\CacheInterface\n{\n    \/**\n     * Instantiates an KVSQLite3 object and opens an SQLite3 database.\n     *\n     * @param null|string $path_file_db File path of the SQLite3 file to be saved.\n     *\n     * If the file path is not provided then the database will be opened\n     * \"in-memory\" and will be disposable.\n     * If the argument is an empty string then the database will be opened in file\n     * under temp directory and will be disposable as well.\n     * In these cases, user should dump to a file to make the database be permanent\n     * before closing the script.\n     *\n     * @suppress PhanTypeInvalidThrowsIsInterface\n     * @throws \\RuntimeException\n     *   \\RuntimeException MUST be thrown in any case of instantiation failure.\n     *   Such as failing to open or create the database and etc.\n     *\/\n    public function __construct(string $path_file_db = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"src\/classes\/KVSQLite3Methods.php","source":"<?php\n\n\/**\n *  PRIVATE Methods of KVSQLite3 Class.\n * ============================================================================\n *\n * - Method names should be in lowerCamelCase.\n * - Methods should have PHPDocs and clearly defined type hints.\n * - Place the methods in alphabetical order.\n * - About Exceptions to be thrown\n *   - InvalidArgumentException\n *       Thrown on user input error. Such as malformed argument value.\n *   - RuntimeException\n *       Thrown on errors that are unable to prevent. For example, well-formed\n *       argument given but failes because of the user environment. Such as file\n *       access permission and etc.\n *   - Exception\n *       Other exceptions other than the above.\n *\/\n\ndeclare(strict_types=1);\n\nnamespace KEINOS\\KVSQLite3;\n\ntrait KVSQLite3Methods\n{\n    use KVSQLite3Properties;\n\n    \/**\n     * Converts the sent TTL to seconds.\n     *\n     * For the details see \"set\" interface description at:\n     *   - \/src\/classes\/psr-16\/CacheInterface.php\n     *\n     * @param  int|\\DateInterval|null $ttl\n     * @return int|null\n     * @throws \\InvalidArgumentException\n     *\/\n    private function convertTtlToSeconds($ttl)\n    {\n        if (is_null($ttl)) {\n            return null; \/\/ No-expiration-time-set\n        }\n\n        if (empty($ttl)) {\n            return 0;\n        }\n\n        if (is_integer($ttl)) {\n            return $ttl;\n        }\n\n        \/**\n         * @psalm-suppress RedundantConditionGivenDocblockType\n         *\/\n        if ($ttl instanceof \\DateInterval) {\n            \/\/ @phpstan-ignore-next-line That gives \"Cannot call method add() on DateTime|false.\" error\n            $seconds = (int) \\DateTime::createFromFormat('U', '0')->add($ttl)->format('U');\n            return intval($seconds);\n        }\n\n        \/\/ @phpstan-ignore-next-line Suppress \"Unreachable statement\"\n        throw new \\InvalidArgumentException(\n            sprintf(\n                'Expiration date must be an integer, a DateInterval or null, \"%s\" given',\n                \\is_object($ttl) ? \\get_class($ttl) : \\gettype($ttl)\n            )\n        );\n    }\n\n    \/**\n     * Creates a new table into the database.\n     *\n     * - Table info\n     *   - @row integer key_hash  Hashed vale of \"key_raw\" in integer as a primary key.\n     *   - @row text    key_raw   User defined key\/ID to store the data.\n     *   - @row varchar value     Data to be stored.\n     *   - @row integer expire    UNIX timestamp to treat as expired. By default 0 will\n     *                            be set and meaning \"no-expiration time specified\".\n     *                            When the value is smaller than the current UNIX time\n     *                            stamp, it means that the stored data had been expired.\n     *   - @row integer update    Time stamp when the data was updated.\n     *   - @row integer created   Time stamp when the data was created.\n     *\n     * @param string $name_table Name of the table to create.\n     *\n     * @throws \\Exception\n     *    Throws an Exception on failure.\n     *\/\n    private function createTable(string $name_table): void\n    {\n        $queries_table = [\n            'key_hash INTEGER NOT NULL PRIMARY KEY',\n            'key_raw TEXT',\n            'value VARCHAR',\n            'expire INTEGER DEFAULT NULL'\n        ];\n        $query_table = implode(',', $queries_table);\n\n        $query = \"CREATE TABLE IF NOT EXISTS ${name_table}(${query_table});\";\n        $this->executeQuery($query);\n    }\n\n    \/**\n     * Decode the encoded data.\n     *\n     * See \"encodeData()\" method for details.\n     *\n     * @param  string $data_encoded\n     * @return mixed\n     *\/\n    private function decodeData(string $data_encoded)\n    {\n        return unserialize(rawurldecode($data_encoded));\n    }\n\n\n    \/**\n     * Delete value from database\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\RuntimeException\n     *    Throws an Exception on failure.\n     *\/\n    private function deleteValueFromDB(string $key): bool\n    {\n        $table = $this->getNameTableDefault();\n        $rowid = $this->hashKeyToRowID($key);\n\n        $query  = \"DELETE FROM ${table} WHERE rowid = ${rowid};\";\n        try {\n            $this->executeQuery($query);\n            return true;\n        } catch (\\Exception $e) {\n            $msg = 'ERROR: Failed to delete data.' . PHP_EOL . ' - Query: ' . $query;\n            $msg = $this->formatMessageExceptionError($e, $msg);\n            throw new \\RuntimeException($msg);\n        }\n    }\n\n    \/**\n     * Encode the data to a safe and storable string.\n     *\n     * This might be an overhead using this method and there might be a better\n     * solution. But I gave up thinking of escaping and all, just to be secure\n     * against SQL injections. So I kept this as simple as possible.\n     * Though, any PR of simple, fast and secure method is welcome!\n     * For a benchmark comparison see\/use: \/bench\/MethodEncodeDataBench.php\n     *\n     * @param  mixed $data_raw\n     * @return string\n     *\/\n    private function encodeData($data_raw): string\n    {\n        return rawurlencode(serialize($data_raw));\n    }\n\n    \/**\n     * Execute SQL query without return but Exception.\n     *\n     * To get\/receive the results in array, use \"requestQuery()\" method.\n     *\n     * @param  string $query\n     * @return void\n     * @throws \\Exception\n     *    Throws an Exception on failure.\n     *\/\n    private function executeQuery(string $query): void\n    {\n        if ($this->db === null) {\n            $msg = 'Failed to open database.' . PHP_EOL\n                   . '- No DB instance found.' .  PHP_EOL;\n            throw new \\Exception($msg);\n        }\n\n        try {\n            $this->db->exec($query);\n        } catch (\\Exception $e) {\n            $msg_append = '- Failed to execute query.' . PHP_EOL\n                        . '  Query: ' . trim($query) . PHP_EOL;\n            $msg_error = $this->formatMessageExceptionError($e, $msg_append);\n            throw new \\Exception($msg_error);\n        }\n    }\n\n    \/**\n     * Format the catched exeption\/error to be comfortable to read.\n     *\n     * @param  object $e          Catched object when try.\n     * @param  string $msg_append Additional message to append.\n     * @return string\n     *\/\n    private function formatMessageExceptionError($e, string $msg_append = ''): string\n    {\n        $msg_error  = '';\n        $msg_append = trim($msg_append);\n        if (method_exists($e, '__toString')) {\n            $capture   = explode(':', $e->__toString(), 2);\n            $msg_error = $capture[0] . PHP_EOL . '- ' . $capture[1];\n        }\n        $msg_append = empty($msg_append) ? '' : $msg_append . PHP_EOL;\n\n        return trim($msg_error) . PHP_EOL . $msg_append;\n    }\n\n    \/**\n     * @return int\n     *\/\n    private function getLifeTimeDefault(): int\n    {\n        return $this->time_ttl_default;\n    }\n\n    \/**\n     * @return string\n     *\/\n    private function getMsgErrorInvalidKey()\n    {\n        return <<< 'HEREDOC'\n- The key must be in:\n    * UTF-8 encoding (also NOT in ISO-8859-1)\n    * Characters of: \/[^A-Za-z0-9_\\.]+\/\n    * Max length of up to 64 characters\nHEREDOC;\n    }\n\n    \/**\n     * @return string\n     *\/\n    private function getNameTableDefault(): string\n    {\n        return $this->name_table_default;\n    }\n\n    \/**\n     * Gets the raw value from \"Value\" column of the database.\n     *\n     * @param  string $key\n     * @return string Encoded data with encodeData() function.\n     * @throws \\InvalidArgumentException MUST be thrown if the $key string is not a legal value.\n     * @throws \\RuntimeException         MUST be thrown if the $key does not exist.\n     *\/\n    private function getValueFromDB(string $key): string\n    {\n        if (! $this->isCompliantKey($key)) {\n            throw new \\InvalidArgumentException('ERROR: Invalid key given.');\n        }\n\n        $table = $this->getNameTableDefault();\n        $rowid = $this->hashKeyToRowID($key);\n\n        $query = \"SELECT * FROM ${table} WHERE rowid=${rowid};\";\n        $item  = $this->requestQuery($query);\n\n        if (! isset($item['key_raw'])) {\n            throw new \\RuntimeException('ERROR: \"key_raw\" column missing.');\n        }\n\n        if ($item['key_raw'] !== $key) {\n            $msg = 'ERROR: Hash value of the key collided.' . PHP_EOL\n                   . '  - Request key: ' . $key . PHP_EOL\n                   . '  - Collide key: ' . $item['key_raw'] . PHP_EOL;\n            throw new \\RuntimeException($msg);\n        }\n\n        if (! isset($item['value'])) {\n            throw new \\RuntimeException('ERROR: \"value\" column missing.');\n        }\n\n        if (isset($item['expire'])) {\n            if ($item['expire'] < time()) {\n                throw new \\RuntimeException('Data had been expired. At:' . $item['expire']);\n            }\n        }\n\n        return (string) $item['value']; \/\/ Encoded Data\n    }\n\n    \/**\n     * Converts a string into an unique 8 Byte integer.\n     *\n     * This method is based on the below article:\n     *   - https:\/\/qiita.com\/KEINOS\/items\/c92268386d265042ea16#tsdr (in Japanese)\n     *\n     * In SQLite3, searching with a rowid is twice as fast as searching with a\n     * primary key value. And defining the table with a primary key as \"INTEGER\n     * PRIMARY KEY\" the primary key becomes an \"alias\" of a rowid.\n     * So, in this method we \"hash\" the key string into an integer to use it as\n     * a primary key value to be equivalent to rowid.\n     * Also, to prevent collision as possible, we use two different hash algo-\n     * rythms and mix them to create an 8 Byte integer.\n     *\n     * - rowid is max 8 Byte which is 16 chars long in HEX string.\n     *\n     * @param  string $key  String of the primary key.\n     * @return int\n     *\/\n    private function hashKeyToRowID(string $key): int\n    {\n        $len = 8; \/\/ Length of 4 Byte hex characters\n        $hash_upper = substr(hash('md5', $key), 0, $len);\n        $hash_lower = substr(hash('sha512', $key), 0, $len);\n\n        return intVal(hexdec($hash_upper . $hash_lower));\n    }\n\n    \/**\n     * Verifies a string if it's compliant to the MUST key requirement of PSR-16.\n     *\n     * - Based on MUST requirement of PSR-16 key definition.\n     *   - @ref https:\/\/www.php-fig.org\/psr\/psr-16\/#12-definitions\n     * - String of the key MUST be:\n     *     A-Z, a-z, 0-9, _, and . in any order in UTF-8 encoding and a length\n     *     of up to 64 characters.\n     *\n     * @param  string $key The unique cache key of the item.\n     * @return bool\n     *\/\n    private function isCompliantKey(string $key): bool\n    {\n        if (strlen($key) > 64) {\n            $msg_error = 'The key value is too long.' . PHP_EOL . $this->getMsgErrorInvalidKey();\n            throw new \\InvalidArgumentException($msg_error);\n        }\n\n        return $this->isCompliantString($key);\n    }\n\n    \/**\n     * Verifies if a string is only in permitted characters.\n     *\n     * Based on MUST requirement of PSR-16 key definition.\n     * String MUST be:\n     *     A-Z, a-z, 0-9, _, and . in any order in UTF-8 encoding.\n     *     @ref https:\/\/www.php-fig.org\/psr\/psr-16\/#12-definitions\n     *\n     * @param  string $string  The string to be checked.\n     * @return bool   True if the key is compliant to the MUST key requirements. False\n     *                if there was an error.\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if the $key string is not a legal value.\n     *\/\n    private function isCompliantString(string $string): bool\n    {\n        \/\/ Characters available\n        $pattern = '\/[^A-Za-z0-9_\\\\.]\/';\n        \/\/ Reason to use preg_match see: \/bench\/FunctionIsCompliantStringBench.php\n        if (preg_match($pattern, $string) !== 0) {\n            $msg_error = 'The key value uses non-available characters.' . PHP_EOL . $this->getMsgErrorInvalidKey();\n            throw new \\InvalidArgumentException($msg_error);\n        }\n\n        return true;\n    }\n\n    \/**\n     * @return bool True if the DB was opened in-memory. False if opened in-file\n     *              including temporary database (\"$db = new \\SQLite3('');\")\n     *\/\n    private function isDBInMemory(): bool\n    {\n        return $this->flag_inmemory;\n    }\n\n    \/**\n     * Sets SQLite3 object into \"db\" property and the file path to \"path_file_db\" property.\n     *\n     * @param  string $path_file_db\n     * @throws \\Exception\n     *    Throws an Exception from \\SQLite3 Class on failure.\n     *\/\n    private function openDB(string $path_file_db): void\n    {\n        $this->db = new \\SQLite3($path_file_db);\n        $this->path_file_db = $path_file_db;\n    }\n\n    \/**\n     * Executes SQL query and returns the results in array.\n     *\n     * @param  string $query\n     * @return array<int|string,int|string>\n     * @throws \\InvalidArgumentException MUST be thrown if the $key string is not a legal value.\n     * @throws \\RuntimeException         MUST be thrown if the return value is not an array.\n     *\/\n    private function requestQuery(string $query): array\n    {\n        if (! isset($this->db)) {\n            throw new \\InvalidArgumentException('ERROR: No DB instance found.');\n        }\n\n        \/\/ @phpstan-ignore-next-line Suppress \"Unreachable statement\"\n        $result = $this->db->query($query)->fetchArray();\n\n        if (! is_array($result)) {\n            $msg = 'ERROR: Invalid return type.' . PHP_EOL\n                    . '  - Retruned type: ' . gettype($result) . PHP_EOL\n                    . '  - Returned value: ' . print_r($result, true);\n            throw new \\RuntimeException($msg);\n        }\n\n        if (empty($result)) {\n            throw new \\RuntimeException('ERROR: Empty data returned.');\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Inserts data into the database.\n     *\n     * If the key already exists, it will overwrite the value.For the details see\n     * \"set()\" at: \/src\/classes\/psr-16\/CacheInterface.php\n     *\n     * @param  string                 $key     The key to store data.\n     * @param  mixed                  $value   Int, string, array and some simple objects.\n     * @param  null|int|\\DateInterval $ttl     Lifetime. Null sets data as limitless lifetime.\n     * @return bool\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown with a clear message on fail.\n     *\/\n    private function setValueToDB(string $key, $value, $ttl = null): bool\n    {\n        if (! $this->isCompliantKey($key)) {\n            throw new \\InvalidArgumentException('ERROR: Invalid key given.');\n        }\n\n        \/**\n         * @psalm-suppress PossiblyNullOperand\n         *\/\n        $expire = is_null($ttl) ? 'NULL' : time() + $this->convertTtlToSeconds($ttl);\n        $table  = $this->getNameTableDefault();\n        $rowid  = $this->hashKeyToRowID($key);\n        $data   = $this->encodeData($value);\n        $value_table = \"${rowid},'${key}','${data}',${expire}\";\n\n        \/\/ Insert or update\/replace.\n        \/\/ Reason for not using \"Upsert\" see: .\/bench\/MethodSetValueToDbBench.php\n        try {\n            $query = \"INSERT OR REPLACE INTO ${table} VALUES(${value_table});\";\n                $this->executeQuery($query);\n        } catch (\\Exception $e) {\n            $msg = $this->formatMessageExceptionError($e, 'ERROR: Failed to insert\/update data.');\n            throw new \\InvalidArgumentException($msg);\n        }\n\n        return true;\n    }\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,12,0,null,null,12,0,null,null,12,12,null,null,null,null,null,0,null,0,0,null,null,null,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,65,null,null,null,null,65,null,65,65,64,null,null,null,null,null,null,null,null,null,null,null,29,null,null,null,null,null,null,null,null,null,null,null,null,null,6,6,null,6,null,6,6,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,35,null,null,null,null,null,null,null,null,null,null,null,null,null,null,65,0,0,0,null,null,null,65,1,1,1,1,1,null,64,null,null,null,null,null,null,null,null,null,null,13,13,13,13,13,null,13,null,13,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,6,null,null,null,null,null,null,null,null,null,null,null,33,null,null,null,null,null,null,null,null,null,null,null,null,33,0,null,null,33,33,null,33,33,null,24,0,null,null,24,0,0,0,0,null,null,24,0,null,null,24,9,3,null,null,null,21,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,34,34,34,null,34,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,36,0,0,null,null,36,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,40,null,40,6,6,null,null,34,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,65,65,65,null,null,null,null,null,null,null,null,null,null,null,33,0,null,null,null,33,null,33,12,12,12,12,null,null,24,0,null,null,24,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,30,0,null,null,null,null,null,27,27,27,27,27,null,null,null,null,27,27,0,0,0,null,null,27,null,null]},{"name":"src\/classes\/KVSQLite3Properties.php","source":"<?php\n\n\/**\n * Properties to be used in KVSQLite3 Class.\n * ============================================================================\n *\n * - Properties should be pre-defined here, in alphabetical order.\n * - Varibale names should be in lower_snake_case.\n *\/\n\n declare(strict_types=1);\n\nnamespace KEINOS\\KVSQLite3;\n\ntrait KVSQLite3Properties\n{\n    \/**\n     * Stores an SQLite3 object.\n     *\n     * @var \\SQLite3|null\n     *\/\n    protected $db = null;\n\n    \/**\n     * True if the databese was created in-memory.\n     *\n     * @var bool\n     *\/\n    protected $flag_inmemory = false;\n\n    \/**\n     * @var int\n     *\/\n    protected $time_ttl_default = 0;\n\n    \/**\n     * @var string\n     *\/\n    protected $name_table_default = 'table_default';\n\n    \/**\n     * Path to the SQLite3 database file.\n     *\n     * If the value is \"null\" then it will be created in-memory and will be\n     * disposable. If it's empty string then it will be created in temp dir\n     * and will be disposable as well.\n     * @var string|null\n     *\/\n    protected $path_file_db = null;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"src\/classes\/psr-16\/CacheInterface.php","source":"<?php declare(strict_types=1);\n\/**\n *  PSR-16 defined Simple Cache Interface.\n * ============================================================================\n *\n * - @refs https:\/\/www.php-fig.org\/psr\/psr-16\/\n * - Method names should be in lowerCamelCase.\n * - Place the methods in alphabetical order.\n *\/\n\nnamespace Psr\\SimpleCache;\n\ninterface CacheInterface\n{\n    \/**\n     * Wipes clean the entire cache's keys.\n     *\n     * @return bool True on success and false on failure.\n     *\/\n    public function clear();\n\n    \/**\n     * Delete an item from the cache by its unique key.\n     *\n     * @param string $key The unique cache key of the item to delete.\n     *\n     * @return bool True if the item was successfully removed. False if there was an error.\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if the $key string is not a legal value.\n     *\/\n    public function delete(string $key);\n\n    \/**\n     * Deletes multiple cache items in a single operation.\n     *\n     * @param iterable<string,mixed> $keys A list of string-based keys to be deleted.\n     *\n     * @return bool True if the items were successfully removed. False if there was an error.\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if $keys is neither an array nor a Traversable,\n     *   or if any of the $keys are not a legal value.\n     *\/\n    public function deleteMultiple(iterable $keys);\n\n    \/**\n     * Fetches a value from the cache.\n     *\n     * @param string $key      The unique key of this item in the cache.\n     * @param mixed  $default  Default value to return if the key does not exist. (Optional)\n     *                         If this value is not set then \\RuntimeException will be thrown\n     *                         if the key does not exist.\n     *\n     * @return mixed The value of the item from the cache, or $default in case of cache miss.\n     *\n     * @throws \\InvalidArgumentException MUST be thrown if the $key string is not a legal value.\n     * @throws \\RuntimeException         Throws if the key does not exist and $default parameter\n     *                                   is not set.\n     *\/\n    public function get(string $key, $default = null);\n\n    \/**\n     * Obtains multiple cache items by their unique keys.\n     *\n     * @param iterable<string,mixed> $keys     A list of keys that can obtained in a single operation.\n     * @param mixed                  $default  Default value to return for keys that do not exist.\n     *\n     * @return iterable<string,mixed> A list of key => value pairs. Cache keys that do not exist or\n     *                                are stale will have $default as value.\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if $keys is neither an array nor a Traversable,\n     *   or if any of the $keys are not a legal value.\n     *\/\n    public function getMultiple(iterable $keys, $default = null);\n\n    \/**\n     * Determines whether an item is present in the cache.\n     *\n     * NOTE: It is recommended that has() is only to be used for cache warming type purposes\n     * and not to be used within your live applications operations for get\/set, as this method\n     * is subject to a race condition where your has() will return true and immediately after,\n     * another script can remove it, making the state of your app out of date.\n     *\n     * @param string $key The cache item key.\n     *\n     * @return bool\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if the $key string is not a legal value.\n     *\/\n    public function has(string $key);\n\n    \/**\n     * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.\n     *\n     * @param string                 $key   The key of the item to store.\n     * @param mixed                  $value The value of the item to store. Must be serializable.\n     * @param null|int|\\DateInterval $ttl   Optional. The TTL value of this item in seconds. If no value\n     *                                      is sent then the driver will treat the cache as \"no-expiration-\n     *                                      time-specified\" which is 0. If an integer or \\DateInterval\n     *                                      object is sent, then the driver will set the expiration time\n     *                                      as \"current UNIX timestamp + ttl(seconds)\" in \"expire\" column\n     *                                      of the database.\n     *                                      Note that seconds will be treated as absolute value, which\n     *                                      means that sending a negative value such as \"-3\" will be added\n     *                                      to the current timestamp as \"3\".\n     *\n     * @return bool True on success and false on failure.\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if the $key string is not a legal value.\n     *\/\n    public function set(string $key, $value, $ttl = null);\n\n    \/**\n     * Persists a set of key => value pairs in the cache, with an optional TTL.\n     *\n     * @param iterable<string,mixed> $values  A list of key => value pairs for a multiple-set operation.\n     * @param null|int|\\DateInterval $ttl     Optional. The TTL value of this item. If no value is sent and\n     *                                        the driver supports TTL then the library may set a default value\n     *                                        for it or let the driver take care of that.\n     *\n     * @return bool True on success and false on failure.\n     *\n     * @throws \\InvalidArgumentException\n     *   MUST be thrown if $values is neither an array nor a Traversable,\n     *   or if any of the $values are not a legal value.\n     *\/\n    public function setMultiple(iterable $values, $ttl = null);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"src\/functions.php","source":"<?php\n\n\/**\n * Functions.\n * ============================================================================\n *\n * - Place the functions in alphabetical order.\n *\/\n\ndeclare(strict_types=1);\n\nnamespace KEINOS\\KVSQLite3;\n\n\/**\n * General-purpose dummy function.\n *\n * @param string $data\n *\n * @return string Returns the same value of the given parameter.\n *\/\nfunction parrotry(string $data): string\n{\n    return $data;\n}\n\n\/**\n * Indent String\n *\n * @param  string $string  Value to be indented.\n * @param  string $indent  Indentation string. (Optional)\n * @return string\n *\/\nfunction indentString(string $string, string $indent = '  '): string\n{\n    return str_replace(PHP_EOL, PHP_EOL . $indent, $string);\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,13,null,null,null,null,null,null,null,null,null,null,null,0,null]}],"environment":{"packagist_version":"2.2.0"}}